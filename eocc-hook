#!/usr/bin/env node
/**
 * eocc-hook - Eyes on Claude Code event monitoring script (Node.js)
 *
 * Usage: eocc-hook <event_type> [matcher]
 *
 * This script is called from ~/.claude/settings.json and logs events from all Claude Code sessions.
 */

const fs = require("node:fs");
const path = require("node:path");
const os = require("node:os");
const { execSync } = require("node:child_process");

function isoTimestampUtc() {
  return new Date().toISOString();
}

function basename(p) {
  const clean = String(p || "").replace(/\/+$/, "");
  return clean ? path.basename(clean) : "";
}

function safeJsonParse(text) {
  try {
    const v = JSON.parse(text);
    if (v && typeof v === "object" && !Array.isArray(v)) return v;
    return {};
  } catch {
    return {};
  }
}

function getString(obj, key, fallback = "") {
  const v = obj ? obj[key] : undefined;
  if (v === undefined || v === null) return fallback;
  if (typeof v === "string") return v;
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return fallback;
}

function whichCommand(cmd) {
  try {
    return execSync(`which ${cmd}`, { encoding: "utf8", timeout: 5000 }).trim();
  } catch {
    return "";
  }
}

async function readStdin() {
  if (process.stdin.isTTY) return "{}";
  const chunks = [];
  for await (const chunk of process.stdin) chunks.push(Buffer.from(chunk));
  const text = Buffer.concat(chunks).toString("utf8");
  return text.trim() ? text : "{}";
}

function appendLine(filePath, line) {
  fs.appendFileSync(filePath, line + "\n", { encoding: "utf8" });
}

async function main() {
  const eventType = process.argv[2] || "unknown";
  const matcher = process.argv[3] || "";

  const home = os.homedir();
  const logDir = path.join(home, ".eocc", "logs");
  const logFile = path.join(logDir, "events.jsonl");

  fs.mkdirSync(logDir, { recursive: true });

  const inputText = await readStdin();
  const rawInput = safeJsonParse(inputText);

  const projectDir = process.env.CLAUDE_PROJECT_DIR || "unknown";
  const projectName = basename(projectDir) || "unknown";
  const tmuxPane = process.env.TMUX_PANE || "";

  const sessionId = getString(rawInput, "session_id", "unknown");
  const message = getString(rawInput, "message", "");
  let notificationType = getString(rawInput, "notification_type", "");
  const toolName = getString(rawInput, "tool_name", "");

  // For notification events, use matcher as notification type if not in input
  if (eventType === "notification" && !notificationType) {
    notificationType = matcher;
  }

  const timestamp = isoTimestampUtc();

  // Capture binary paths for session_start and stop events
  let npxPath = "";
  let tmuxPath = "";
  if (eventType === "session_start" || eventType === "stop") {
    npxPath = whichCommand("npx");
    tmuxPath = whichCommand("tmux");
  }

  const payload = {
    timestamp,
    event: eventType,
    matcher,
    project_name: projectName,
    project_dir: projectDir,
    session_id: sessionId,
    message,
    notification_type: notificationType,
    tool_name: toolName,
    tmux_pane: tmuxPane,
    npx_path: npxPath,
    tmux_path: tmuxPath,
  };

  const payloadJson = JSON.stringify(payload);

  appendLine(logFile, payloadJson);
}

main().catch(() => {
  // Never fail the hook call (best-effort logging).
  process.exit(0);
});
