#!/usr/bin/env node
/**
 * eocc-hook - Eyes on Claude Code event monitoring script (Node.js)
 *
 * Usage: eocc-hook <event_type> [matcher]
 *
 * This script is called from ~/.claude/settings.json and logs events from all Claude Code sessions.
 */

const fs = require("node:fs");
const path = require("node:path");
const os = require("node:os");

function isoTimestampUtc() {
  return new Date().toISOString();
}

function localTimeHHMMSS(d = new Date()) {
  const pad = (n) => String(n).padStart(2, "0");
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}

function basename(p) {
  const clean = String(p || "").replace(/\/+$/, "");
  return clean ? path.basename(clean) : "";
}

function safeJsonParse(text) {
  try {
    const v = JSON.parse(text);
    if (v && typeof v === "object" && !Array.isArray(v)) return v;
    return {};
  } catch {
    return {};
  }
}

function getString(obj, key, fallback = "") {
  const v = obj ? obj[key] : undefined;
  if (v === undefined || v === null) return fallback;
  if (typeof v === "string") return v;
  if (typeof v === "number" || typeof v === "boolean") return String(v);
  return fallback;
}

function getEmoji(eventType, notificationType) {
  if (eventType === "notification") {
    if (notificationType === "permission_prompt") return "ðŸ”";
    if (notificationType === "idle_prompt") return "â³";
    return "ðŸ””";
  }
  if (eventType === "stop") return "âœ…";
  if (eventType === "session_start") return "ðŸš€";
  if (eventType === "session_end") return "ðŸ";
  if (eventType === "pre_tool_use") return "ðŸ”§";
  if (eventType === "post_tool_use") return "ðŸ”§";
  if (eventType === "user_prompt_submit") return "ðŸ’¬";
  return "ðŸ“Œ";
}

async function readStdin() {
  if (process.stdin.isTTY) return "{}";
  const chunks = [];
  for await (const chunk of process.stdin) chunks.push(Buffer.from(chunk));
  const text = Buffer.concat(chunks).toString("utf8");
  return text.trim() ? text : "{}";
}

function appendLine(filePath, line) {
  fs.appendFileSync(filePath, line + "\n", { encoding: "utf8" });
}

function writeFile(filePath, content) {
  fs.writeFileSync(filePath, content, { encoding: "utf8" });
}

async function main() {
  const eventType = process.argv[2] || "unknown";
  const matcher = process.argv[3] || "";

  const home = os.homedir();
  const logDir = path.join(home, ".eocc", "logs");
  const logFile = path.join(logDir, "events.jsonl");
  const latestFile = path.join(logDir, "latest.json");
  const consoleLog = path.join(logDir, "console.log");
  const stdinDebugLog = path.join(logDir, "stdin-debug.log");

  fs.mkdirSync(logDir, { recursive: true });

  const inputText = await readStdin();
  const rawInput = safeJsonParse(inputText);

  const projectDir = process.env.CLAUDE_PROJECT_DIR || "unknown";
  const projectName = basename(projectDir) || "unknown";

  const sessionId = getString(rawInput, "session_id", "unknown");
  const message = getString(rawInput, "message", "");
  let notificationType = getString(rawInput, "notification_type", "");
  const toolName = getString(rawInput, "tool_name", "");

  // For notification events, use matcher as notification type if not in input
  if (eventType === "notification" && !notificationType) {
    notificationType = matcher;
  }

  const timestamp = isoTimestampUtc();
  const timestampLocal = localTimeHHMMSS();

  // Debug: save raw stdin input
  appendLine(
    stdinDebugLog,
    `[${timestamp}] EVENT=${eventType} MATCHER=${matcher} INPUT=${inputText}`
  );

  const payload = {
    timestamp,
    event: eventType,
    matcher,
    project_name: projectName,
    project_dir: projectDir,
    session_id: sessionId,
    message,
    notification_type: notificationType,
    tool_name: toolName,
    raw_input: rawInput,
  };

  const payloadJson = JSON.stringify(payload);

  appendLine(logFile, payloadJson);
  writeFile(latestFile, payloadJson);

  const emoji = getEmoji(eventType, notificationType);
  const matcherSuffix = matcher ? ` (${matcher})` : "";
  const messageSuffix = message ? ` - ${message}` : "";
  appendLine(
    consoleLog,
    `[${timestampLocal}] ${emoji} ${projectName}: ${eventType}${matcherSuffix}${messageSuffix}`
  );
}

main().catch(() => {
  // Never fail the hook call (best-effort logging).
  process.exit(0);
});
