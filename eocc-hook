#!/bin/bash
# eocc-hook - Eyes on Claude Code event monitoring script
#
# Usage: eocc-hook <event_type> [matcher]
#
# This script is called from ~/.claude/settings.json and
# logs events from all Claude Code sessions.

set -euo pipefail

# Log directory
LOG_DIR="${HOME}/.eocc/logs"
LOG_FILE="${LOG_DIR}/events.jsonl"
LATEST_FILE="${LOG_DIR}/latest.json"

# Create directory if it doesn't exist
mkdir -p "$LOG_DIR"

# Arguments
EVENT_TYPE="${1:-unknown}"
MATCHER="${2:-}"

# Read JSON from stdin
# Note: Claude Code passes hook data via stdin as JSON
INPUT=""
if [ -t 0 ]; then
    # stdin is a terminal, no input
    INPUT='{}'
else
    # Read all stdin
    INPUT=$(cat 2>/dev/null || echo '{}')
fi

# Fallback if input is empty
if [ -z "$INPUT" ] || [ "$INPUT" = "" ]; then
    INPUT='{}'
fi

# Debug: save raw stdin input to log
echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] EVENT=$EVENT_TYPE MATCHER=$MATCHER INPUT=$INPUT" >> "${LOG_DIR}/stdin-debug.log"

# Extract session ID and message
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // "unknown"' 2>/dev/null || echo "unknown")
MESSAGE=$(echo "$INPUT" | jq -r '.message // empty' 2>/dev/null || echo "")
NOTIFICATION_TYPE=$(echo "$INPUT" | jq -r '.notification_type // empty' 2>/dev/null || echo "")
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty' 2>/dev/null || echo "")

# For notification events, use matcher as notification type if not in input
if [ "$EVENT_TYPE" = "notification" ] && [ -z "$NOTIFICATION_TYPE" ]; then
    NOTIFICATION_TYPE="$MATCHER"
fi

# Extract project name (last directory name from CLAUDE_PROJECT_DIR)
PROJECT_DIR="${CLAUDE_PROJECT_DIR:-unknown}"
PROJECT_NAME=$(basename "$PROJECT_DIR" 2>/dev/null || echo "unknown")

# Timestamp
TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
TIMESTAMP_LOCAL=$(date +%H:%M:%S)

# Create payload
PAYLOAD=$(jq -nc \
  --arg event "$EVENT_TYPE" \
  --arg matcher "$MATCHER" \
  --arg project_dir "$PROJECT_DIR" \
  --arg project_name "$PROJECT_NAME" \
  --arg session_id "$SESSION_ID" \
  --arg message "$MESSAGE" \
  --arg notification_type "$NOTIFICATION_TYPE" \
  --arg tool_name "$TOOL_NAME" \
  --arg timestamp "$TIMESTAMP" \
  --argjson input "$INPUT" \
  '{
    timestamp: $timestamp,
    event: $event,
    matcher: $matcher,
    project_name: $project_name,
    project_dir: $project_dir,
    session_id: $session_id,
    message: $message,
    notification_type: $notification_type,
    tool_name: $tool_name,
    raw_input: $input
  }' 2>/dev/null || echo '{"error": "failed to create payload"}')

# Append to JSONL file
echo "$PAYLOAD" >> "$LOG_FILE"

# Save latest event to separate file (for debugging)
echo "$PAYLOAD" > "$LATEST_FILE"

# Console output (for debugging)
# Emoji based on event type
case "$EVENT_TYPE" in
    notification)
        case "$NOTIFICATION_TYPE" in
            permission_prompt) EMOJI="ðŸ”" ;;
            idle_prompt) EMOJI="â³" ;;
            *) EMOJI="ðŸ””" ;;
        esac
        ;;
    stop) EMOJI="âœ…" ;;
    session_start) EMOJI="ðŸš€" ;;
    session_end) EMOJI="ðŸ" ;;
    pre_tool_use) EMOJI="ðŸ”§" ;;
    post_tool_use) EMOJI="ðŸ”§" ;;
    user_prompt_submit) EMOJI="ðŸ’¬" ;;
    *) EMOJI="ðŸ“Œ" ;;
esac

# Log message output (to stderr to avoid polluting Claude's transcript)
echo "[$TIMESTAMP_LOCAL] $EMOJI $PROJECT_NAME: $EVENT_TYPE${MATCHER:+ ($MATCHER)}${MESSAGE:+ - $MESSAGE}" >> "${LOG_DIR}/console.log"

exit 0
